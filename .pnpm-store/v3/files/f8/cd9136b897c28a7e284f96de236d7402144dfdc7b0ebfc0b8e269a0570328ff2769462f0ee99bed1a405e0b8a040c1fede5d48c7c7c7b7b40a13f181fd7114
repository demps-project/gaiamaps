{"version":3,"file":"index.modern.mjs","sources":["../node_modules/@humanwhocodes/momoa/api.js","../lib/errors.ts","../lib/types.ts","../lib/get_type.ts","../lib/get_member_value.ts","../lib/get_array.ts","../lib/get_object.ts","../lib/array_is_numbers.ts","../lib/enforce_position.ts","../lib/enforce_position_array.ts","../lib/enforce_same_position.ts","../lib/enforce_bbox.ts","../lib/forbid_confusing_properties.ts","../lib/index.ts","../lib/check_duplicate_keys.ts"],"sourcesContent":["'use strict';\n\nObject.defineProperty(exports, '__esModule', { value: true });\n\n/**\n * @fileoverview JSON syntax helpers\n * @author Nicholas C. Zakas\n */\n\n//-----------------------------------------------------------------------------\n// Predefined Tokens\n//-----------------------------------------------------------------------------\n\nconst LBRACKET = \"[\";\nconst RBRACKET = \"]\";\nconst LBRACE = \"{\";\nconst RBRACE = \"}\";\nconst COLON = \":\";\nconst COMMA = \",\";\n\nconst TRUE = \"true\";\nconst FALSE = \"false\";\nconst NULL = \"null\";\n\nconst QUOTE = \"\\\"\";\n\nconst expectedKeywords = new Map([\n    [\"t\", TRUE],\n    [\"f\", FALSE],\n    [\"n\", NULL]\n]);\n\nconst escapeToChar = new Map([\n    [QUOTE, QUOTE],\n    [\"\\\\\", \"\\\\\"],\n    [\"/\", \"/\"],\n    [\"b\", \"\\b\"],\n    [\"n\", \"\\n\"],\n    [\"f\", \"\\f\"],\n    [\"r\", \"\\r\"],\n    [\"t\", \"\\t\"]\n]);\n\nconst knownTokenTypes = new Map([\n    [LBRACKET, \"Punctuator\"],\n    [RBRACKET, \"Punctuator\"],\n    [LBRACE, \"Punctuator\"],\n    [RBRACE, \"Punctuator\"],\n    [COLON, \"Punctuator\"],\n    [COMMA, \"Punctuator\"],\n    [TRUE, \"Boolean\"],\n    [FALSE, \"Boolean\"],\n    [NULL, \"Null\"]\n]);\n\n/**\n * @fileoverview JSON tokenization/parsing errors\n * @author Nicholas C. Zakas\n */\n\n\n/**\n * Base class that attaches location to an error.\n */\nclass ErrorWithLocation extends Error {\n\n    /**\n     * \n     * @param {string} message The error message to report. \n     * @param {int} loc.line The line on which the error occurred.\n     * @param {int} loc.column The column in the line where the error occurrred.\n     * @param {int} loc.index The index in the string where the error occurred.\n     */\n    constructor(message, { line, column, index }) {\n        super(`${ message } (${ line }:${ column})`);\n\n        /**\n         * The line on which the error occurred.\n         * @type int\n         * @property line\n         */\n        this.line = line;\n\n        /**\n         * The column on which the error occurred.\n         * @type int\n         * @property column\n         */\n        this.column = column;\n        \n        /**\n         * The index into the string where the error occurred.\n         * @type int\n         * @property index\n         */\n        this.index = index;\n    }\n\n}\n\n/**\n * Error thrown when an unexpected character is found during tokenizing.\n */\nclass UnexpectedChar extends ErrorWithLocation {\n\n    /**\n     * Creates a new instance.\n     * @param {string} unexpected The character that was found.\n     * @param {Object} loc The location information for the found character.\n     */\n    constructor(unexpected, loc) {\n        super(`Unexpected character ${ unexpected } found.`, loc);\n    }\n}\n\n/**\n * Error thrown when an unexpected token is found during parsing.\n */\nclass UnexpectedToken extends ErrorWithLocation {\n\n    /**\n     * Creates a new instance.\n     * @param {string} expected The character that was expected. \n     * @param {string} unexpected The character that was found.\n     * @param {Object} loc The location information for the found character.\n     */\n    constructor(token) {\n        super(`Unexpected token ${ token.type }(${ token.value }) found.`, token.loc.start);\n    }\n}\n\n/**\n * Error thrown when the end of input is found where it isn't expected.\n */\nclass UnexpectedEOF extends ErrorWithLocation {\n\n    /**\n     * Creates a new instance.\n     * @param {Object} loc The location information for the found character.\n     */\n    constructor(loc) {\n        super(\"Unexpected end of input found.\", loc);\n    }\n}\n\n/**\n * @fileoverview JSON tokenizer\n * @author Nicholas C. Zakas\n */\n\n//-----------------------------------------------------------------------------\n// Helpers\n//-----------------------------------------------------------------------------\n\nconst QUOTE$1 = \"\\\"\";\nconst SLASH = \"/\";\nconst STAR = \"*\";\n\nconst DEFAULT_OPTIONS = {\n    comments: false,\n    ranges: false\n};\n\nfunction isWhitespace(c) {\n    return /[\\s\\n]/.test(c);\n}\n\nfunction isDigit(c) {\n    return c >= \"0\" && c <= \"9\";\n}\n\nfunction isHexDigit(c) {\n    return isDigit(c) || /[a-f]/i.test(c);\n}\n\nfunction isPositiveDigit(c) {\n    return c >= \"1\" && c <= \"9\";\n}\n\nfunction isKeywordStart(c) {\n    return /[tfn]/.test(c);\n}\n\nfunction isNumberStart(c) {\n    return isDigit(c) || c === \".\" || c === \"-\";\n}\n\n//-----------------------------------------------------------------------------\n// Main\n//-----------------------------------------------------------------------------\n\n/**\n * Creates an iterator over the tokens representing the source text.\n * @param {string} text The source text to tokenize.\n * @returns {Iterator} An iterator over the tokens. \n */\nfunction tokenize(text, options) {\n\n    options = Object.freeze({\n        ...DEFAULT_OPTIONS,\n        ...options\n    });\n\n    let offset = -1;\n    let line = 1;\n    let column = 0;\n    let newLine = false;\n\n    const tokens = [];\n\n\n    function createToken(tokenType, value, startLoc, endLoc) {\n        \n        const endOffset = startLoc.offset + value.length;\n        let range = options.ranges ? {\n            range: [startLoc.offset, endOffset]\n        } : undefined;\n        \n        return {\n            type: tokenType,\n            value,\n            loc: {\n                start: startLoc,\n                end: endLoc || {\n                    line: startLoc.line,\n                    column: startLoc.column + value.length,\n                    offset: endOffset\n                }\n            },\n            ...range\n        };\n    }\n\n    function next() {\n        let c = text.charAt(++offset);\n    \n        if (newLine) {\n            line++;\n            column = 1;\n            newLine = false;\n        } else {\n            column++;\n        }\n\n        if (c === \"\\r\") {\n            newLine = true;\n\n            // if we already see a \\r, just ignore upcoming \\n\n            if (text.charAt(offset + 1) === \"\\n\") {\n                offset++;\n            }\n        } else if (c === \"\\n\") {\n            newLine = true;\n        }\n\n        return c;\n    }\n\n    function locate() {\n        return {\n            line,\n            column,\n            offset\n        };\n    }\n\n    function readKeyword(c) {\n\n        // get the expected keyword\n        let value = expectedKeywords.get(c);\n\n        // check to see if it actually exists\n        if (text.slice(offset, offset + value.length) === value) {\n            offset += value.length - 1;\n            column += value.length - 1;\n            return { value, c: next() };\n        }\n\n        // find the first unexpected character\n        for (let j = 1; j < value.length; j++) {\n            if (value[j] !== text.charAt(offset + j)) {\n                unexpected(next());\n            }\n        }\n\n    }\n\n    function readString(c) {\n        let value = c;\n        c = next();\n\n        while (c && c !== QUOTE$1) {\n\n            // escapes\n            if (c === \"\\\\\") {\n                value += c;\n                c = next();\n\n                if (escapeToChar.has(c)) {\n                    value += c;\n                } else if (c === \"u\") {\n                    value += c;\n                    for (let i = 0; i < 4; i++) {\n                        c = next();\n                        if (isHexDigit(c)) {\n                            value += c;\n                        } else {\n                            unexpected(c);\n                        }\n                    }\n                } else {\n                    unexpected(c);\n                }\n            } else {\n                value += c;\n            }\n\n            c = next();\n        }\n\n        if (!c) {\n            unexpectedEOF();\n        }\n        \n        value += c;\n\n        return { value, c: next() };\n    }\n\n\n    function readNumber(c) {\n\n        let value = \"\";\n\n        // Number may start with a minus but not a plus\n        if (c === \"-\") {\n\n            value += c;\n\n            c = next();\n\n            // Next digit cannot be zero\n            if (!isDigit(c)) {\n                unexpected(c);\n            }\n\n        }\n\n        // Zero must be followed by a decimal point or nothing\n        if (c === \"0\") {\n\n            value += c;\n\n            c = next();\n            if (isDigit(c)) {\n                unexpected(c);\n            }\n\n        } else {\n            if (!isPositiveDigit(c)) {\n                unexpected(c);\n            }\n\n            do {\n                value += c;\n                c = next();\n            } while (isDigit(c));\n        }\n\n        // Decimal point may be followed by any number of digits\n        if (c === \".\") {\n\n            do {\n                value += c;\n                c = next();\n            } while (isDigit(c));\n        }\n\n        // Exponent is always last\n        if (c === \"e\" || c === \"E\") {\n\n            value += c;\n            c = next();\n\n            if (c === \"+\" || c === \"-\") {\n                value += c;\n                c = next();\n            }\n\n            /*\n             * Must always have a digit in this position to avoid:\n             * 5e\n             * 12E+\n             * 42e-\n             */\n            if (!isDigit(c)) {\n                unexpected(c);\n            }\n\n            while (isDigit(c)) {\n                value += c;\n                c = next();\n            }\n        }\n\n\n        return { value, c };\n    }\n\n    /**\n     * Reads in either a single-line or multi-line comment.\n     * @param {string} c The first character of the comment.\n     * @returns {string} The comment string.\n     * @throws {UnexpectedChar} when the comment cannot be read.\n     * @throws {UnexpectedEOF} when EOF is reached before the comment is\n     *      finalized.\n     */\n    function readComment(c) {\n\n        let value = c;\n\n        // next character determines single- or multi-line\n        c = next();\n\n        // single-line comments\n        if (c === \"/\") {\n            \n            do {\n                value += c;\n                c = next();\n            } while (c && c !== \"\\r\" && c !== \"\\n\");\n\n            return { value, c };\n        }\n\n        // multi-line comments\n        if (c === STAR) {\n\n            while (c) {\n                value += c;\n                c = next();\n\n                // check for end of comment\n                if (c === STAR) {\n                    value += c;\n                    c = next();\n                    \n                    //end of comment\n                    if (c === SLASH) {\n                        value += c;\n\n                        /*\n                         * The single-line comment functionality cues up the\n                         * next character, so we do the same here to avoid\n                         * splitting logic later.\n                         */\n                        c = next();\n                        return { value, c };\n                    }\n                }\n            }\n\n            unexpectedEOF();\n            \n        }\n\n        // if we've made it here, there's an invalid character\n        unexpected(c);        \n    }\n\n\n    /**\n     * Convenience function for throwing unexpected character errors.\n     * @param {string} c The unexpected character.\n     * @returns {void}\n     * @throws {UnexpectedChar} always.\n     */\n    function unexpected(c) {\n        throw new UnexpectedChar(c, locate());\n    }\n\n    /**\n     * Convenience function for throwing unexpected EOF errors.\n     * @returns {void}\n     * @throws {UnexpectedEOF} always.\n     */\n    function unexpectedEOF() {\n        throw new UnexpectedEOF(locate());\n    }\n\n    let c = next();\n\n    while (offset < text.length) {\n\n        while (isWhitespace(c)) {\n            c = next();\n        }\n\n        if (!c) {\n            break;\n        }\n\n        const start = locate();\n\n        // check for easy case\n        if (knownTokenTypes.has(c)) {\n            tokens.push(createToken(knownTokenTypes.get(c), c, start));\n            c = next();\n        } else if (isKeywordStart(c)) {\n            const result = readKeyword(c);\n            let value = result.value;\n            c = result.c;\n            tokens.push(createToken(knownTokenTypes.get(value), value, start));\n        } else if (isNumberStart(c)) {\n            const result = readNumber(c);\n            let value = result.value;\n            c = result.c;\n            tokens.push(createToken(\"Number\", value, start));\n        } else if (c === QUOTE$1) {\n            const result = readString(c);\n            let value = result.value;\n            c = result.c;\n            tokens.push(createToken(\"String\", value, start));\n        } else if (c === SLASH && options.comments) {\n            const result = readComment(c);\n            let value = result.value;\n            c = result.c;\n            tokens.push(createToken(value.startsWith(\"//\") ? \"LineComment\" : \"BlockComment\", value, start, locate()));\n        } else {\n            unexpected(c);\n        }\n    }\n\n    return tokens;\n\n}\n\n/**\n * @fileoverview Momoa JSON AST types\n * @author Nicholas C. Zakas\n */\n\nconst types = {\n    document(body, parts = {}) {\n        return {\n            type: \"Document\",\n            body,\n            ...parts\n        };\n    },\n    string(value, parts = {}) {\n        return {\n            type: \"String\",\n            value,\n            ...parts\n        };\n    },\n    number(value, parts = {}) {\n        return {\n            type: \"Number\",\n            value,\n            ...parts\n        };\n    },\n    boolean(value, parts = {}) {\n        return {\n            type: \"Boolean\",\n            value,\n            ...parts\n        };\n    },\n    null(parts = {}) {\n        return {\n            type: \"Null\",\n            value: \"null\",\n            ...parts\n        };\n    },\n    array(elements, parts = {}) {\n        return {\n            type: \"Array\",\n            elements,\n            ...parts\n        };\n    },\n    object(members, parts = {}) {\n        return {\n            type: \"Object\",\n            members,\n            ...parts\n        };\n    },\n    member(name, value, parts = {}) {\n        return {\n            type: \"Member\",\n            name,\n            value,\n            ...parts\n        };\n    },\n\n};\n\n/**\n * @fileoverview JSON parser\n * @author Nicholas C. Zakas\n */\n\n//-----------------------------------------------------------------------------\n// Helpers\n//-----------------------------------------------------------------------------\n\nconst DEFAULT_OPTIONS$1 = {\n    tokens: false,\n    comments: false,\n    ranges: false\n};\n\n/**\n * Converts a JSON-encoded string into a JavaScript string, interpreting each\n * escape sequence.\n * @param {Token} token The string token to convert into a JavaScript string.\n * @returns {string} A JavaScript string.\n */\nfunction getStringValue(token) {\n    \n    // slice off the quotation marks\n    let value = token.value.slice(1, -1);\n    let result = \"\";\n    let escapeIndex = value.indexOf(\"\\\\\");\n    let lastIndex = 0;\n\n    // While there are escapes, interpret them to build up the result\n    while (escapeIndex >= 0) {\n\n        // append the text that happened before the escape\n        result += value.slice(lastIndex, escapeIndex);\n\n        // get the character immediately after the \\\n        const escapeChar = value.charAt(escapeIndex + 1);\n        \n        // check for the non-Unicode escape sequences first\n        if (escapeToChar.has(escapeChar)) {\n            result += escapeToChar.get(escapeChar);\n            lastIndex = escapeIndex + 2;\n        } else if (escapeChar === \"u\") {\n            const hexCode = value.slice(escapeIndex + 2, escapeIndex + 6);\n            if (hexCode.length < 4 || /[^0-9a-f]/i.test(hexCode)) {\n                throw new ErrorWithLocation(\n                    `Invalid unicode escape \\\\u${ hexCode}.`,\n                    {\n                        line: token.loc.start.line,\n                        column: token.loc.start.column + escapeIndex,\n                        offset: token.loc.start.offset + escapeIndex\n                    }\n                );\n            }\n            \n            result += String.fromCharCode(parseInt(hexCode, 16));\n            lastIndex = escapeIndex + 6;\n        } else {\n            throw new ErrorWithLocation(\n                `Invalid escape \\\\${ escapeChar }.`,\n                {\n                    line: token.loc.start.line,\n                    column: token.loc.start.column + escapeIndex,\n                    offset: token.loc.start.offset + escapeIndex\n                }\n            );\n        }\n\n        // find the next escape sequence\n        escapeIndex = value.indexOf(\"\\\\\", lastIndex);\n    }\n\n    // get the last segment of the string value\n    result += value.slice(lastIndex);\n\n    return result;\n}\n\n/**\n * Gets the JavaScript value represented by a JSON token.\n * @param {Token} token The JSON token to get a value for.\n * @returns {*} A number, string, boolean, or `null`. \n */\nfunction getLiteralValue(token) {\n    switch (token.type) {\n    case \"Boolean\":\n        return token.value === \"true\";\n        \n    case \"Number\":\n        return Number(token.value);\n\n    case \"Null\":\n        return null;\n\n    case \"String\":\n        return getStringValue(token);\n    }\n}\n\n//-----------------------------------------------------------------------------\n// Main Function\n//-----------------------------------------------------------------------------\n\n/**\n * \n * @param {string} text The text to parse.\n * @param {boolean} [options.tokens=false] Determines if tokens are returned in\n *      the AST. \n * @param {boolean} [options.comments=false] Determines if comments are allowed\n *      in the JSON.\n * @param {boolean} [options.ranges=false] Determines if ranges will be returned\n *      in addition to `loc` properties.\n * @returns {Object} The AST representing the parsed JSON.\n * @throws {Error} When there is a parsing error. \n */\nfunction parse(text, options) {\n\n    options = Object.freeze({\n        ...DEFAULT_OPTIONS$1,\n        ...options\n    });\n\n    const tokens = tokenize(text, {\n        comments: !!options.comments,\n        ranges: !!options.ranges\n    });\n    let tokenIndex = 0;\n\n    function nextNoComments() {\n        return tokens[tokenIndex++];\n    }\n    \n    function nextSkipComments() {\n        const nextToken = tokens[tokenIndex++];\n        if (nextToken && nextToken.type.endsWith(\"Comment\")) {\n            return nextSkipComments();\n        }\n\n        return nextToken;\n\n    }\n\n    // determine correct way to evaluate tokens based on presence of comments\n    const next = options.comments ? nextSkipComments : nextNoComments;\n\n    function assertTokenValue(token, value) {\n        if (!token || token.value !== value) {\n            throw new UnexpectedToken(token);\n        }\n    }\n\n    function assertTokenType(token, type) {\n        if (!token || token.type !== type) {\n            throw new UnexpectedToken(token);\n        }\n    }\n\n    function createRange(start, end) {\n        return options.ranges ? {\n            range: [start.offset, end.offset]\n        } : undefined;\n    }\n\n    function createLiteralNode(token) {\n        const range = createRange(token.loc.start, token.loc.end);\n\n        return {\n            type: token.type,\n            value: getLiteralValue(token),\n            loc: {\n                start: {\n                    ...token.loc.start\n                },\n                end: {\n                    ...token.loc.end\n                }\n            },\n            ...range\n        };\n    }\n\n\n    function parseProperty(token) {\n        assertTokenType(token, \"String\");\n        const name = createLiteralNode(token);\n\n        token = next();\n        assertTokenValue(token, \":\");\n        const value = parseValue();\n        const range = createRange(name.loc.start, value.loc.end);\n\n        return types.member(name, value, {\n            loc: {\n                start: {\n                    ...name.loc.start\n                },\n                end: {\n                    ...value.loc.end\n                }\n            },\n            ...range\n        });\n    }\n\n    function parseObject(firstToken) {\n\n        // The first token must be a { or else it's an error\n        assertTokenValue(firstToken, \"{\");\n\n        const members = [];\n        let token = next();\n\n        if (token && token.value !== \"}\") {\n            do {\n    \n                // add the value into the array\n                members.push(parseProperty(token));\n    \n                token = next();\n    \n                if (token.value === \",\") {\n                    token = next();\n                } else {\n                    break;\n                }\n            } while (token);\n        }\n\n        assertTokenValue(token, \"}\");\n        const range = createRange(firstToken.loc.start, token.loc.end);\n\n        return types.object(members, {\n            loc: {\n                start: {\n                    ...firstToken.loc.start\n                },\n                end: {\n                    ...token.loc.end\n                }\n            },\n            ...range\n        });\n\n    }\n\n    function parseArray(firstToken) {\n\n        // The first token must be a [ or else it's an error\n        assertTokenValue(firstToken, \"[\");\n\n        const elements = [];\n        let token = next();\n        \n        if (token && token.value !== \"]\") {\n\n            do {\n\n              // add the value into the array\n              elements.push(parseValue(token));\n\n              token = next();\n              \n              if (token.value === \",\") {\n                  token = next();\n              } else {\n                  break;\n              }\n            } while (token);\n        }\n\n        assertTokenValue(token, \"]\");\n        const range = createRange(firstToken.loc.start, token.loc.end);\n\n        return types.array(elements, {\n            type: \"Array\",\n            elements,\n            loc: {\n                start: {\n                    ...firstToken.loc.start\n                },\n                end: {\n                    ...token.loc.end\n                }\n            },\n            ...range\n        });\n\n    }\n\n\n\n    function parseValue(token) {\n\n        token = token || next();\n        \n        switch (token.type) {\n        case \"String\":\n        case \"Boolean\":\n        case \"Number\":\n        case \"Null\":\n            return createLiteralNode(token);\n\n        case \"Punctuator\":\n            if (token.value === \"{\") {\n                return parseObject(token);\n            } else if (token.value === \"[\") {\n                return parseArray(token);\n            }\n            /*falls through*/\n\n        default:\n            throw new UnexpectedToken(token);\n        }\n\n    }\n\n    \n    const docBody = parseValue();\n    \n    const unexpectedToken = next();\n    if (unexpectedToken) {\n        throw new UnexpectedToken(unexpectedToken);\n    }\n    \n    \n    const docParts = {\n        loc: {\n            start: {\n                line: 1,\n                column: 1,\n                offset: 0\n            },\n            end: {\n                ...docBody.loc.end\n            }\n        }\n    };\n    \n\n    if (options.tokens) {\n        docParts.tokens = tokens;\n    }\n\n    if (options.ranges) {\n        docParts.range = createRange(docParts.loc.start, docParts.loc.end);\n    }\n\n    return types.document(docBody, docParts);\n\n}\n\n/**\n * @fileoverview Traversal approaches for Momoa JSON AST.\n * @author Nicholas C. Zakas\n */\n\n//-----------------------------------------------------------------------------\n// Data\n//-----------------------------------------------------------------------------\n\nconst childKeys = new Map([\n    [\"Document\", [\"body\"]],\n    [\"Object\", [\"members\"]],\n    [\"Member\", [\"name\", \"value\"]],\n    [\"Array\", [\"elements\"]],\n    [\"String\", []],\n    [\"Number\", []],\n    [\"Boolean\", []],\n    [\"Null\", []]\n]);\n\n//-----------------------------------------------------------------------------\n// Helpers\n//-----------------------------------------------------------------------------\n\n/**\n * Determines if a given value is an object.\n * @param {*} value The value to check.\n * @returns {boolean} True if the value is an object, false if not. \n */\nfunction isObject(value) {\n    return value && (typeof value === \"object\");\n}\n\n/**\n * Determines if a given value is an AST node.\n * @param {*} value The value to check.\n * @returns {boolean} True if the value is a node, false if not. \n */\nfunction isNode(value) {\n    return isObject(value) && (typeof value.type === \"string\");\n}\n\n//-----------------------------------------------------------------------------\n// Exports\n//-----------------------------------------------------------------------------\n\n/**\n * Traverses an AST from the given node.\n * @param {Node} root The node to traverse from \n * @param {Object} visitor An object with an `enter` and `exit` method. \n */\nfunction traverse(root, visitor) {\n\n    /**\n     * Recursively visits a node.\n     * @param {Node} node The node to visit.\n     * @param {Node} parent The parent of the node to visit.\n     * @returns {void}\n     */\n    function visitNode(node, parent) {\n\n        if (typeof visitor.enter === \"function\") {\n            visitor.enter(node, parent);\n        }\n\n        for (const key of childKeys.get(node.type)) {\n            const value = node[key];\n\n            if (isObject(value)) {\n                if (Array.isArray(value)) {\n                    value.forEach(child => visitNode(child, node));\n                } else if (isNode(value)) {\n                    visitNode(value, node);\n                }\n            }\n        }\n\n        if (typeof visitor.exit === \"function\") {\n            visitor.exit(node, parent);\n        }\n    }\n\n    visitNode(root);\n}\n\n/**\n * Creates an iterator over the given AST.\n * @param {Node} root The root AST node to traverse. \n * @param {Function} [filter] A filter function to determine which steps to\n *      return;\n * @returns {Iterator} An iterator over the AST.  \n */\nfunction iterator(root, filter = () => true) {\n\n    const traversal = [];\n\n    traverse(root, {\n        enter(node, parent) {\n            traversal.push({ node, parent, phase: \"enter\" });\n        },\n        exit(node, parent) {\n            traversal.push({ node, parent, phase: \"exit\" });\n        }\n    });\n\n    return traversal.filter(filter).values();\n}\n\n/**\n * @fileoverview Evaluator for Momoa AST.\n * @author Nicholas C. Zakas\n */\n\n//-----------------------------------------------------------------------------\n// Exports\n//-----------------------------------------------------------------------------\n\n/**\n * Evaluates a Momoa AST node into a JavaScript value.\n * @param {Node} node The node to interpet.\n * @returns {*} The JavaScript value for the node. \n */\nfunction evaluate(node) {\n    switch (node.type) {\n    case \"String\":\n    case \"Number\":\n    case \"Boolean\":\n        return node.value;\n\n    case \"Null\":\n        return null;\n\n    case \"Array\":\n        return node.elements.map(evaluate);\n\n    case \"Object\": {\n\n        const object = {};\n\n        node.members.forEach(member => {\n            object[evaluate(member.name)] = evaluate(member.value);\n        });    \n\n        return object;\n    }    \n\n    case \"Document\":\n        return evaluate(node.body);\n\n    case \"Property\":\n        throw new Error(\"Cannot evaluate object property outside of an object.\");\n\n    default:\n        throw new Error(`Unknown node type ${ node.type }.`);\n    }\n}\n\n/**\n * @fileoverview Printer for Momoa AST.\n * @author Nicholas C. Zakas\n */\n\n//-----------------------------------------------------------------------------\n// Exports\n//-----------------------------------------------------------------------------\n\n/**\n * Converts a Momoa AST back into a JSON string.\n * @param {Node} node The node to print.\n * @param {int} [options.indent=0] The number of spaces to indent each line. If\n *      greater than 0, then newlines and indents will be added to output. \n * @returns {string} The JSON representation of the AST.\n */\nfunction print(node, { indent = 0 } = {}) {\n    const value = evaluate(node);\n    return JSON.stringify(value, null, indent);\n}\n\n/**\n * @fileoverview File defining the interface of the package.\n * @author Nicholas C. Zakas\n */\n\nexports.evaluate = evaluate;\nexports.iterator = iterator;\nexports.parse = parse;\nexports.print = print;\nexports.tokenize = tokenize;\nexports.traverse = traverse;\nexports.types = types;\n","import { Node } from '@humanwhocodes/momoa';\nimport { HintIssue } from './types';\n\nexport function makeIssue(message: string, node: Node): HintIssue {\n  return {\n    message,\n    severity: 'error',\n    // node,\n    from: node.loc.start.offset,\n    to: node.loc.end.offset,\n  };\n}\n\nexport class HintError extends Error {\n  issues: HintIssue[] = [];\n\n  constructor(issues: HintIssue[]) {\n    super();\n    // restore prototype chain\n    const actualProto = new.target.prototype;\n    Object.setPrototypeOf(this, actualProto);\n    this.issues = issues;\n  }\n\n  get message() {\n    return JSON.stringify(this.issues, null, 2);\n  }\n}\n","import { GeoJSON } from 'geojson';\n\nexport type GeoJSONTypeSet = Set<GeoJSON['type']>;\n\nexport interface HintIssue {\n  from: number;\n  to: number;\n  node?: Node;\n  severity: 'error';\n  message: string;\n}\n\nexport interface Ctx {\n  issues: HintIssue[];\n  valid: Array<undefined | HintIssue[]>;\n}\n\nexport const GEOJSON_FEATURE_TYPE = new Set<GeoJSON['type']>(['Feature']);\n\nexport const GEOJSON_GEOMETRY_TYPES = new Set<GeoJSON['type']>([\n  'Point',\n  'MultiPoint',\n  'Polygon',\n  'MultiPolygon',\n  'LineString',\n  'MultiLineString',\n  'GeometryCollection',\n]);\n\nexport const GEOJSON_GEOMETRY_TYPES_EX_GEOMETRY_COLLECTION = new Set<\n  GeoJSON['type']\n>([\n  'Point',\n  'MultiPoint',\n  'Polygon',\n  'MultiPolygon',\n  'LineString',\n  'MultiLineString',\n]);\n\nexport const GEOJSON_TYPES = new Set<GeoJSON['type']>(\n  Array.from(GEOJSON_GEOMETRY_TYPES).concat([\n  'Feature',\n  'FeatureCollection',\n]));\n","import { Ctx, GeoJSONTypeSet } from './types';\nimport { GeoJSON } from 'geojson';\nimport { HintError, makeIssue } from './errors';\nimport { Node } from '@humanwhocodes/momoa';\n\nexport function getType(ctx: Ctx, node: Node, allowedTypes: GeoJSONTypeSet) {\n  if (node.type !== 'Object') {\n    throw new HintError([\n      makeIssue('Expected an object, but found an incorrect type.', node),\n    ]);\n  }\n\n  const typeMember = node.members.find((member) => {\n    return member.name.value === 'type';\n  });\n\n  if (!typeMember) {\n    ctx.issues.push(\n      makeIssue('This GeoJSON object is missing its type member.', node)\n    );\n    return {};\n  }\n\n  const value = typeMember.value;\n\n  if (value.type !== 'String') {\n    ctx.issues.push(\n      makeIssue('The type member should have been a string.', node)\n    );\n\n    return {};\n  }\n\n  if (!allowedTypes.has(value.value as any)) {\n    ctx.issues.push(\n      makeIssue('This type of GeoJSON object is not allowed here.', node)\n    );\n\n    return {};\n  }\n\n  return {\n    type: value.value as GeoJSON['type'],\n    objectNode: node,\n  };\n}\n","import { makeIssue } from './errors';\nimport { ObjectNode } from '@humanwhocodes/momoa';\nimport { Ctx } from './types';\n\nexport function getMemberValue(ctx: Ctx, node: ObjectNode, name: string) {\n  const member = node.members.find((member) => {\n    return member.name.value === name;\n  });\n\n  if (!member) {\n    ctx.issues.push(\n      makeIssue(\n        `This GeoJSON object requires a ${name} member but it is missing.`,\n        node\n      )\n    );\n\n    return null;\n  }\n\n  return member.value;\n}\n","import { makeIssue } from './errors';\nimport { Node, ArrayNode } from '@humanwhocodes/momoa';\nimport { Ctx } from './types';\n\nexport function getArray(ctx: Ctx, node: Node | null): ArrayNode | null {\n  if (node?.type === 'Array') return node;\n  if (node) {\n    ctx.issues.push(makeIssue('This must be an array.', node));\n  }\n  return null;\n}\n","import { makeIssue } from './errors';\nimport { Node, ObjectNode } from '@humanwhocodes/momoa';\nimport { Ctx } from './types';\n\nexport function getObject(ctx: Ctx, node: Node | null): ObjectNode | null {\n  if (node?.type === 'Object') return node;\n  if (node) {\n    ctx.issues.push(makeIssue('This must be an object.', node));\n  }\n  return null;\n}\n","import { Node } from '@humanwhocodes/momoa';\nimport { makeIssue } from './errors';\nimport { Ctx } from './types';\n\nexport function arrayIsNumbers(ctx: Ctx, elements: Node[], name: string) {\n  for (const element of elements) {\n    if (element.type !== 'Number') {\n      ctx.issues.push(\n        makeIssue(`Each element in a ${name} must be a number.`, element)\n      );\n      return;\n    }\n  }\n}\n","import { makeIssue } from './errors';\nimport { ArrayNode } from '@humanwhocodes/momoa';\nimport { arrayIsNumbers } from './array_is_numbers';\nimport { Ctx } from './types';\n\nexport function enforcePosition(ctx: Ctx, node: ArrayNode | null) {\n  // This error has already been caught. Allow a no-op for simplicity.\n  if (node === null) return;\n\n  if (node.elements.length < 2 || node.elements.length > 3) {\n    ctx.issues.push(\n      makeIssue(\n        `A position should have 2 or 3 elements - found ${node.elements.length}.`,\n        node\n      )\n    );\n  }\n\n  arrayIsNumbers(ctx, node.elements, 'position');\n}\n","import { makeIssue } from './errors';\nimport { enforcePosition } from './enforce_position';\nimport { enforceSamePosition } from './enforce_same_position';\nimport { Node, ArrayNode } from '@humanwhocodes/momoa';\nimport { Ctx } from './types';\n\nfunction getArray(ctx: Ctx, node: Node): ArrayNode | null {\n  if (node.type !== 'Array') {\n    ctx.issues.push(\n      makeIssue('Expected to find an array of positions here.', node)\n    );\n    return null;\n  }\n  return node;\n}\n\ntype PositionKind = 'Polygon' | 'LineString';\n\nexport function enforcePositionArray(\n  ctx: Ctx,\n  node: Node | null,\n  kind?: PositionKind\n) {\n  // This error has already been caught. Allow a no-op for simplicity.\n  if (node === null) return;\n\n  node = getArray(ctx, node);\n  if (!node) return;\n\n  for (const element of node.elements) {\n    if (element.type !== 'Array') {\n      ctx.issues.push(\n        makeIssue(\n          'Expected to find a position here, found another type.',\n          element\n        )\n      );\n      return;\n    } else {\n      enforcePosition(ctx, element);\n    }\n  }\n\n  switch (kind) {\n    case 'LineString': {\n      if (node.elements.length < 2) {\n        ctx.issues.push(\n          makeIssue('Expected to find two or more positions here.', node)\n        );\n      }\n      break;\n    }\n    case 'Polygon':\n      if (node.elements.length < 4) {\n        ctx.issues.push(\n          makeIssue('Expected to find four or more positions here.', node)\n        );\n      }\n      enforceSamePosition(ctx, node);\n      break;\n  }\n}\n\nexport function enforcePositionArray2(\n  ctx: Ctx,\n  node: Node | null,\n  kind?: PositionKind\n) {\n  // This error has already been caught. Allow a no-op for simplicity.\n  if (node === null) return;\n\n  node = getArray(ctx, node);\n  if (!node) return;\n\n  for (const element of node.elements) {\n    enforcePositionArray(ctx, element, kind);\n  }\n}\n\nexport function enforcePositionArray3(\n  ctx: Ctx,\n  node: ArrayNode | null,\n  kind?: PositionKind\n) {\n  // This error has already been caught. Allow a no-op for simplicity.\n  if (node === null) return;\n\n  node = getArray(ctx, node);\n  if (!node) return;\n\n  for (const element of node.elements) {\n    enforcePositionArray2(ctx, element, kind);\n  }\n}\n","import { makeIssue } from './errors';\nimport { ArrayNode, NumberNode } from '@humanwhocodes/momoa';\nimport { Ctx } from './types';\n\nexport function enforceSamePosition(ctx: Ctx, node: ArrayNode) {\n  const first = node.elements[0] as ArrayNode;\n  const last = node.elements[node.elements.length - 1] as ArrayNode;\n  const len = Math.max(first.elements.length, last.elements.length);\n\n  for (let j = 0; j < len; j++) {\n    const firstValue = (first.elements[j] as NumberNode | undefined)?.value;\n    const secondValue = (last.elements[j] as NumberNode | undefined)?.value;\n    if (firstValue !== secondValue) {\n      ctx.issues.push(\n        makeIssue(\n          'First and last positions of a Polygon or MultiPolygon’s ring should be the same.',\n          first\n        ),\n        makeIssue(\n          'First and last positions of a Polygon or MultiPolygon’s ring should be the same.',\n          last\n        )\n      );\n      return;\n    }\n  }\n}\n","import { makeIssue } from './errors';\nimport { ObjectNode } from '@humanwhocodes/momoa';\nimport { getArray } from './get_array';\nimport { arrayIsNumbers } from './array_is_numbers';\nimport { Ctx } from './types';\n\nexport function enforceBbox(ctx: Ctx, node: ObjectNode) {\n  const member = node.members.find((member) => {\n    return member.name.value === 'bbox';\n  });\n\n  // bboxes are optional\n  if (member === undefined) return;\n\n  const array = getArray(ctx, member.value);\n\n  if (!array) return;\n\n  if (!(array.elements.length === 4 || array.elements.length === 6)) {\n    ctx.issues.push(makeIssue('A bbox must have 4 or 6 positions', array));\n  }\n\n  arrayIsNumbers(ctx, array.elements, 'bbox');\n}\n","import { makeIssue } from './errors';\nimport { ObjectNode, MemberNode } from '@humanwhocodes/momoa';\nimport { Ctx } from './types';\n\ntype PropertiesFrom = 'Feature' | 'FeatureCollection' | 'Geometry';\n\nfunction forbidProperty(\n  ctx: Ctx,\n  member: MemberNode,\n  propertiesFrom: PropertiesFrom,\n  name: string\n) {\n  if (member.name.value === name) {\n    ctx.issues.push(\n      makeIssue(\n        `${propertiesFrom} objects cannot contain a member named ${member.name.value}`,\n        member.name\n      )\n    );\n  }\n}\n\nconst FORBIDDEN_PROPERTIES = {\n  Geometry: ['properties', 'geometry', 'features'],\n  Feature: ['features'],\n  FeatureCollection: ['properties', 'coordinates'],\n} as const;\n\nexport function forbidConfusingProperties(\n  ctx: Ctx,\n  node: ObjectNode,\n  propertiesFrom: PropertiesFrom\n) {\n  for (const member of node.members) {\n    for (const property of FORBIDDEN_PROPERTIES[propertiesFrom]) {\n      forbidProperty(ctx, member, propertiesFrom, property);\n    }\n  }\n}\n","import {\n  parse,\n  evaluate,\n  DocumentNode,\n  Node,\n  ObjectNode,\n} from '@humanwhocodes/momoa';\nimport { GeoJSON } from 'geojson';\nimport { HintError, makeIssue } from './errors';\nimport {\n  GeoJSONTypeSet,\n  GEOJSON_TYPES,\n  GEOJSON_GEOMETRY_TYPES,\n  GEOJSON_GEOMETRY_TYPES_EX_GEOMETRY_COLLECTION,\n  GEOJSON_FEATURE_TYPE,\n  HintIssue,\n  Ctx,\n} from './types';\nimport { getType } from './get_type';\nimport { getMemberValue } from './get_member_value';\nimport { getArray } from './get_array';\nimport { getObject } from './get_object';\nimport { enforcePosition } from './enforce_position';\nimport { checkDuplicateKeys } from './check_duplicate_keys';\nimport {\n  enforcePositionArray,\n  enforcePositionArray2,\n  enforcePositionArray3,\n} from './enforce_position_array';\nimport { enforceBbox } from './enforce_bbox';\nimport { forbidConfusingProperties } from './forbid_confusing_properties';\n\ntype Checker = (ctx: Ctx, node: ObjectNode) => void;\n\nfunction getCoordinates(ctx: Ctx, node: ObjectNode) {\n  const coordinatesMember = getMemberValue(ctx, node, 'coordinates');\n  if (!coordinatesMember) return null;\n  return getArray(ctx, coordinatesMember);\n}\n\nconst checkGeometryShared: Checker = (ctx, node) => {\n  enforceBbox(ctx, node);\n  forbidConfusingProperties(ctx, node, 'Geometry');\n};\n\nconst checkLineString: Checker = (ctx, node) => {\n  enforcePositionArray(ctx, getCoordinates(ctx, node), 'LineString');\n  checkGeometryShared(ctx, node);\n};\n\nconst checkMultiLineString: Checker = (ctx, node) => {\n  enforcePositionArray2(ctx, getCoordinates(ctx, node), 'LineString');\n  checkGeometryShared(ctx, node);\n};\n\nconst checkPolygon: Checker = (ctx, node) => {\n  enforcePositionArray2(ctx, getCoordinates(ctx, node), 'Polygon');\n  checkGeometryShared(ctx, node);\n};\n\nconst checkMultiPolygon: Checker = (ctx, node) => {\n  enforcePositionArray3(ctx, getCoordinates(ctx, node), 'Polygon');\n  checkGeometryShared(ctx, node);\n};\n\nconst checkPoint: Checker = (ctx, node) => {\n  enforcePosition(ctx, getCoordinates(ctx, node));\n  checkGeometryShared(ctx, node);\n};\n\nconst checkMultiPoint: Checker = (ctx, node) => {\n  enforcePositionArray(ctx, getCoordinates(ctx, node));\n  checkGeometryShared(ctx, node);\n};\n\nconst checkGeometryCollection: Checker = (ctx, node) => {\n  checkGeometryShared(ctx, node);\n  const geometriesMember = getArray(\n    ctx,\n    getMemberValue(ctx, node, 'geometries')\n  );\n  if (!geometriesMember) return;\n  for (const element of geometriesMember.elements) {\n    checkObject(ctx, element, GEOJSON_GEOMETRY_TYPES_EX_GEOMETRY_COLLECTION);\n  }\n};\n\nconst checkFeature: Checker = (ctx, node) => {\n  forbidConfusingProperties(ctx, node, 'Feature');\n  const geometryMember = getMemberValue(ctx, node, 'geometry');\n  enforceBbox(ctx, node);\n  if (geometryMember?.type !== 'Null') {\n    const geometry = getObject(ctx, geometryMember);\n    if (geometry) checkObject(ctx, geometry, GEOJSON_GEOMETRY_TYPES);\n  }\n\n  const idMember = node.members.find((member) => {\n    return member.name.value === 'id';\n  });\n  if (\n    idMember &&\n    !(idMember.value.type === 'String' || idMember.value.type === 'Number')\n  ) {\n    ctx.issues.push(\n      makeIssue(`The Feature id must be a string or number.`, node)\n    );\n  }\n\n  const properties = getMemberValue(ctx, node, 'properties');\n  if (!properties) {\n    ctx.issues.push(makeIssue(`The properties member is missing.`, node));\n    return;\n  }\n\n  const { type } = properties;\n\n  if (!(type === 'Object' || type === 'Null')) {\n    ctx.issues.push(\n      makeIssue(`The Feature properties member can be an object or null.`, node)\n    );\n  }\n};\n\nconst checkFeatureCollection: Checker = (ctx, node) => {\n  forbidConfusingProperties(ctx, node, 'FeatureCollection');\n  const featuresMember = getArray(ctx, getMemberValue(ctx, node, 'features'));\n  if (!featuresMember) return;\n  for (const feature of featuresMember.elements) {\n    const beforeCount = ctx.issues.length;\n    const obj = getObject(ctx, feature);\n    if (obj) {\n      getType(ctx, obj, GEOJSON_FEATURE_TYPE);\n      checkFeature(ctx, obj);\n    }\n    ctx.valid.push(\n      ctx.issues.length === beforeCount\n        ? undefined\n        : ctx.issues.slice(beforeCount)\n    );\n  }\n};\n\nconst CHECKERS: Record<GeoJSON['type'], Checker> = {\n  LineString: checkLineString,\n  MultiLineString: checkMultiLineString,\n\n  Polygon: checkPolygon,\n  MultiPolygon: checkMultiPolygon,\n\n  Point: checkPoint,\n  MultiPoint: checkMultiPoint,\n\n  GeometryCollection: checkGeometryCollection,\n\n  Feature: checkFeature,\n  FeatureCollection: checkFeatureCollection,\n};\n\nfunction checkObject(\n  ctx: Ctx,\n  node: Node,\n  typeSet: GeoJSONTypeSet = GEOJSON_TYPES\n) {\n  const { type, objectNode } = getType(ctx, node, typeSet);\n  if (!(type && objectNode)) return;\n  checkDuplicateKeys(ctx, objectNode);\n  CHECKERS[type](ctx, objectNode);\n}\n\nfunction checkInternal(jsonStr: string): {\n  ast: DocumentNode | undefined;\n  ctx: Ctx;\n} {\n  const ctx: Ctx = {\n    issues: [],\n    valid: [],\n  };\n  let ast;\n  try {\n    ast = parse(jsonStr, {\n      ranges: true,\n    });\n    checkObject(ctx, ast.body);\n  } catch (e: unknown) {\n    ctx.issues.push({\n      message: `Invalid JSON: ${(e as Error).message}`,\n      from: 0,\n      to: 0,\n      severity: 'error',\n    });\n  }\n\n  return { ast, ctx };\n}\n\n/**\n * Given a string of possibly valid GeoJSON data,\n * return an array of issues. This will handle invalid JSON\n * data, invalid GeoJSON structure, and anything else that will\n * prevent this string of data from being parsed and\n * displayed on a map.\n *\n * check-geojson looks for invalid structure and invalid syntax.\n * It does not check for complex geometry issues like\n * self-intersections, which are hard to detect and don't cause\n * failures in most display & manipulation software.\n */\nexport const getIssues = (jsonStr: string): HintIssue[] => {\n  return checkInternal(jsonStr).ctx.issues;\n};\n\n/**\n * This catches the same issues as `getIssues`, but instead\n * of returning a list of issues, it will throw a HintError\n * if any errors are detected, and return the parsed\n * GeoJSON as an object if no errors are.\n */\nexport const check = (jsonStr: string): GeoJSON => {\n  const { ctx, ast } = checkInternal(jsonStr);\n  if (ctx.issues.length || !ast) throw new HintError(ctx.issues);\n  return evaluate(ast);\n};\n\n/**\n * This method will allow you to parse a possibly-valid\n * bit of GeoJSON data. If nothing can be parsed, it will\n * throw a HintError. However, if the GeoJSON can be parsed,\n * it will return an object with valid features\n * and rejected features along with the reasons why those\n * features were rejected.\n */\nexport const scavenge = (\n  jsonStr: string\n): {\n  result: GeoJSON;\n  rejected: Array<{ feature: any; reasons: HintIssue[] }>;\n} => {\n  const {\n    ctx: { issues, valid },\n    ast,\n  } = checkInternal(jsonStr);\n  // If GeoJSON can't be parsed, throw.\n  if (!ast) throw new HintError(issues);\n  const result = evaluate(ast) as GeoJSON;\n  // If everything was fine, return.\n  if (!issues.length) return { result, rejected: [] };\n  // If there were errors but it's a featurecollection, sift\n  if (result.type === 'FeatureCollection') {\n    return {\n      result: {\n        ...result,\n        features: result.features.filter((_, i) => {\n          return valid[i] === undefined;\n        }),\n      },\n      rejected: result.features.flatMap((feature, i) => {\n        const reasons = valid[i];\n        if (reasons) {\n          return [\n            {\n              feature,\n              reasons,\n            },\n          ];\n        }\n        return [];\n      }),\n    };\n  }\n  // Otherwise, throw\n  throw new HintError(issues);\n};\n\nexport { HintError, HintIssue };\n","import { makeIssue } from './errors';\nimport { ObjectNode } from '@humanwhocodes/momoa';\nimport { Ctx } from './types';\n\nexport function checkDuplicateKeys(ctx: Ctx, parent: ObjectNode): ObjectNode {\n  const keys = new Set<string>();\n  for (const node of parent.members) {\n    const {\n      name: { value },\n    } = node;\n    if (keys.has(value)) {\n      ctx.issues.push(\n        makeIssue('Duplicate properties are ambiguous in GeoJSON', node)\n      );\n    }\n    keys.add(value);\n  }\n  return parent;\n}\n"],"names":["expectedKeywords","Map","escapeToChar","knownTokenTypes","ErrorWithLocation","Error","constructor","message","line","column","index","super","this","UnexpectedChar","unexpected","loc","UnexpectedToken","token","type","value","start","UnexpectedEOF","DEFAULT_OPTIONS","comments","ranges","isWhitespace","c","test","isDigit","isHexDigit","isKeywordStart","isNumberStart","DEFAULT_OPTIONS$1","tokens","getLiteralValue","Number","slice","result","escapeIndex","indexOf","lastIndex","escapeChar","charAt","has","get","offset","hexCode","length","String","fromCharCode","parseInt","getStringValue","evaluate_1","evaluate","node","elements","map","object","members","forEach","member","name","body","severity","from","to","end","HintError","issues","prototype","Object","setPrototypeOf","actualProto","JSON","stringify","GEOJSON_FEATURE_TYPE","Set","GEOJSON_GEOMETRY_TYPES","GEOJSON_GEOMETRY_TYPES_EX_GEOMETRY_COLLECTION","GEOJSON_TYPES","Array","concat","getType","ctx","allowedTypes","makeIssue","typeMember","find","push","objectNode","getArray","getObject","arrayIsNumbers","element","enforcePosition","enforcePositionArray","kind","first","last","len","Math","max","j","_first$elements$j","_last$elements$j","enforceSamePosition","enforceBbox","undefined","array","forbidProperty","propertiesFrom","FORBIDDEN_PROPERTIES","Geometry","Feature","FeatureCollection","forbidConfusingProperties","property","getCoordinates","coordinatesMember","getMemberValue","checkGeometryShared","checkFeature","geometryMember","geometry","checkObject","idMember","properties","CHECKERS","LineString","MultiLineString","enforcePositionArray2","Polygon","MultiPolygon","enforcePositionArray3","Point","MultiPoint","GeometryCollection","geometriesMember","featuresMember","feature","beforeCount","obj","valid","typeSet","checkDuplicateKeys","parent","keys","add","checkInternal","jsonStr","ast","text","options","freeze","newLine","createToken","tokenType","startLoc","endLoc","endOffset","range","next","locate","readKeyword","readString","i","unexpectedEOF","readNumber","isPositiveDigit","readComment","startsWith","tokenize","tokenIndex","nextSkipComments","nextToken","endsWith","assertTokenValue","createRange","createLiteralNode","parseProperty","assertTokenType","parseValue","parts","types","firstToken","parseObject","parseArray","docBody","unexpectedToken","docParts","parse","e","getIssues","check","scavenge","rejected","_extends","features","filter","_","flatMap","reasons"],"mappings":"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"}