{"version":3,"file":"index.esm.js","sources":["../node_modules/@humanwhocodes/momoa/api.js","../lib/errors.ts","../lib/types.ts","../lib/get_type.ts","../lib/get_member_value.ts","../lib/get_array.ts","../lib/get_object.ts","../lib/array_is_numbers.ts","../lib/enforce_position.ts","../lib/enforce_position_array.ts","../lib/enforce_same_position.ts","../lib/enforce_bbox.ts","../lib/forbid_confusing_properties.ts","../lib/index.ts","../lib/check_duplicate_keys.ts"],"sourcesContent":["'use strict';\n\nObject.defineProperty(exports, '__esModule', { value: true });\n\n/**\n * @fileoverview JSON syntax helpers\n * @author Nicholas C. Zakas\n */\n\n//-----------------------------------------------------------------------------\n// Predefined Tokens\n//-----------------------------------------------------------------------------\n\nconst LBRACKET = \"[\";\nconst RBRACKET = \"]\";\nconst LBRACE = \"{\";\nconst RBRACE = \"}\";\nconst COLON = \":\";\nconst COMMA = \",\";\n\nconst TRUE = \"true\";\nconst FALSE = \"false\";\nconst NULL = \"null\";\n\nconst QUOTE = \"\\\"\";\n\nconst expectedKeywords = new Map([\n    [\"t\", TRUE],\n    [\"f\", FALSE],\n    [\"n\", NULL]\n]);\n\nconst escapeToChar = new Map([\n    [QUOTE, QUOTE],\n    [\"\\\\\", \"\\\\\"],\n    [\"/\", \"/\"],\n    [\"b\", \"\\b\"],\n    [\"n\", \"\\n\"],\n    [\"f\", \"\\f\"],\n    [\"r\", \"\\r\"],\n    [\"t\", \"\\t\"]\n]);\n\nconst knownTokenTypes = new Map([\n    [LBRACKET, \"Punctuator\"],\n    [RBRACKET, \"Punctuator\"],\n    [LBRACE, \"Punctuator\"],\n    [RBRACE, \"Punctuator\"],\n    [COLON, \"Punctuator\"],\n    [COMMA, \"Punctuator\"],\n    [TRUE, \"Boolean\"],\n    [FALSE, \"Boolean\"],\n    [NULL, \"Null\"]\n]);\n\n/**\n * @fileoverview JSON tokenization/parsing errors\n * @author Nicholas C. Zakas\n */\n\n\n/**\n * Base class that attaches location to an error.\n */\nclass ErrorWithLocation extends Error {\n\n    /**\n     * \n     * @param {string} message The error message to report. \n     * @param {int} loc.line The line on which the error occurred.\n     * @param {int} loc.column The column in the line where the error occurrred.\n     * @param {int} loc.index The index in the string where the error occurred.\n     */\n    constructor(message, { line, column, index }) {\n        super(`${ message } (${ line }:${ column})`);\n\n        /**\n         * The line on which the error occurred.\n         * @type int\n         * @property line\n         */\n        this.line = line;\n\n        /**\n         * The column on which the error occurred.\n         * @type int\n         * @property column\n         */\n        this.column = column;\n        \n        /**\n         * The index into the string where the error occurred.\n         * @type int\n         * @property index\n         */\n        this.index = index;\n    }\n\n}\n\n/**\n * Error thrown when an unexpected character is found during tokenizing.\n */\nclass UnexpectedChar extends ErrorWithLocation {\n\n    /**\n     * Creates a new instance.\n     * @param {string} unexpected The character that was found.\n     * @param {Object} loc The location information for the found character.\n     */\n    constructor(unexpected, loc) {\n        super(`Unexpected character ${ unexpected } found.`, loc);\n    }\n}\n\n/**\n * Error thrown when an unexpected token is found during parsing.\n */\nclass UnexpectedToken extends ErrorWithLocation {\n\n    /**\n     * Creates a new instance.\n     * @param {string} expected The character that was expected. \n     * @param {string} unexpected The character that was found.\n     * @param {Object} loc The location information for the found character.\n     */\n    constructor(token) {\n        super(`Unexpected token ${ token.type }(${ token.value }) found.`, token.loc.start);\n    }\n}\n\n/**\n * Error thrown when the end of input is found where it isn't expected.\n */\nclass UnexpectedEOF extends ErrorWithLocation {\n\n    /**\n     * Creates a new instance.\n     * @param {Object} loc The location information for the found character.\n     */\n    constructor(loc) {\n        super(\"Unexpected end of input found.\", loc);\n    }\n}\n\n/**\n * @fileoverview JSON tokenizer\n * @author Nicholas C. Zakas\n */\n\n//-----------------------------------------------------------------------------\n// Helpers\n//-----------------------------------------------------------------------------\n\nconst QUOTE$1 = \"\\\"\";\nconst SLASH = \"/\";\nconst STAR = \"*\";\n\nconst DEFAULT_OPTIONS = {\n    comments: false,\n    ranges: false\n};\n\nfunction isWhitespace(c) {\n    return /[\\s\\n]/.test(c);\n}\n\nfunction isDigit(c) {\n    return c >= \"0\" && c <= \"9\";\n}\n\nfunction isHexDigit(c) {\n    return isDigit(c) || /[a-f]/i.test(c);\n}\n\nfunction isPositiveDigit(c) {\n    return c >= \"1\" && c <= \"9\";\n}\n\nfunction isKeywordStart(c) {\n    return /[tfn]/.test(c);\n}\n\nfunction isNumberStart(c) {\n    return isDigit(c) || c === \".\" || c === \"-\";\n}\n\n//-----------------------------------------------------------------------------\n// Main\n//-----------------------------------------------------------------------------\n\n/**\n * Creates an iterator over the tokens representing the source text.\n * @param {string} text The source text to tokenize.\n * @returns {Iterator} An iterator over the tokens. \n */\nfunction tokenize(text, options) {\n\n    options = Object.freeze({\n        ...DEFAULT_OPTIONS,\n        ...options\n    });\n\n    let offset = -1;\n    let line = 1;\n    let column = 0;\n    let newLine = false;\n\n    const tokens = [];\n\n\n    function createToken(tokenType, value, startLoc, endLoc) {\n        \n        const endOffset = startLoc.offset + value.length;\n        let range = options.ranges ? {\n            range: [startLoc.offset, endOffset]\n        } : undefined;\n        \n        return {\n            type: tokenType,\n            value,\n            loc: {\n                start: startLoc,\n                end: endLoc || {\n                    line: startLoc.line,\n                    column: startLoc.column + value.length,\n                    offset: endOffset\n                }\n            },\n            ...range\n        };\n    }\n\n    function next() {\n        let c = text.charAt(++offset);\n    \n        if (newLine) {\n            line++;\n            column = 1;\n            newLine = false;\n        } else {\n            column++;\n        }\n\n        if (c === \"\\r\") {\n            newLine = true;\n\n            // if we already see a \\r, just ignore upcoming \\n\n            if (text.charAt(offset + 1) === \"\\n\") {\n                offset++;\n            }\n        } else if (c === \"\\n\") {\n            newLine = true;\n        }\n\n        return c;\n    }\n\n    function locate() {\n        return {\n            line,\n            column,\n            offset\n        };\n    }\n\n    function readKeyword(c) {\n\n        // get the expected keyword\n        let value = expectedKeywords.get(c);\n\n        // check to see if it actually exists\n        if (text.slice(offset, offset + value.length) === value) {\n            offset += value.length - 1;\n            column += value.length - 1;\n            return { value, c: next() };\n        }\n\n        // find the first unexpected character\n        for (let j = 1; j < value.length; j++) {\n            if (value[j] !== text.charAt(offset + j)) {\n                unexpected(next());\n            }\n        }\n\n    }\n\n    function readString(c) {\n        let value = c;\n        c = next();\n\n        while (c && c !== QUOTE$1) {\n\n            // escapes\n            if (c === \"\\\\\") {\n                value += c;\n                c = next();\n\n                if (escapeToChar.has(c)) {\n                    value += c;\n                } else if (c === \"u\") {\n                    value += c;\n                    for (let i = 0; i < 4; i++) {\n                        c = next();\n                        if (isHexDigit(c)) {\n                            value += c;\n                        } else {\n                            unexpected(c);\n                        }\n                    }\n                } else {\n                    unexpected(c);\n                }\n            } else {\n                value += c;\n            }\n\n            c = next();\n        }\n\n        if (!c) {\n            unexpectedEOF();\n        }\n        \n        value += c;\n\n        return { value, c: next() };\n    }\n\n\n    function readNumber(c) {\n\n        let value = \"\";\n\n        // Number may start with a minus but not a plus\n        if (c === \"-\") {\n\n            value += c;\n\n            c = next();\n\n            // Next digit cannot be zero\n            if (!isDigit(c)) {\n                unexpected(c);\n            }\n\n        }\n\n        // Zero must be followed by a decimal point or nothing\n        if (c === \"0\") {\n\n            value += c;\n\n            c = next();\n            if (isDigit(c)) {\n                unexpected(c);\n            }\n\n        } else {\n            if (!isPositiveDigit(c)) {\n                unexpected(c);\n            }\n\n            do {\n                value += c;\n                c = next();\n            } while (isDigit(c));\n        }\n\n        // Decimal point may be followed by any number of digits\n        if (c === \".\") {\n\n            do {\n                value += c;\n                c = next();\n            } while (isDigit(c));\n        }\n\n        // Exponent is always last\n        if (c === \"e\" || c === \"E\") {\n\n            value += c;\n            c = next();\n\n            if (c === \"+\" || c === \"-\") {\n                value += c;\n                c = next();\n            }\n\n            /*\n             * Must always have a digit in this position to avoid:\n             * 5e\n             * 12E+\n             * 42e-\n             */\n            if (!isDigit(c)) {\n                unexpected(c);\n            }\n\n            while (isDigit(c)) {\n                value += c;\n                c = next();\n            }\n        }\n\n\n        return { value, c };\n    }\n\n    /**\n     * Reads in either a single-line or multi-line comment.\n     * @param {string} c The first character of the comment.\n     * @returns {string} The comment string.\n     * @throws {UnexpectedChar} when the comment cannot be read.\n     * @throws {UnexpectedEOF} when EOF is reached before the comment is\n     *      finalized.\n     */\n    function readComment(c) {\n\n        let value = c;\n\n        // next character determines single- or multi-line\n        c = next();\n\n        // single-line comments\n        if (c === \"/\") {\n            \n            do {\n                value += c;\n                c = next();\n            } while (c && c !== \"\\r\" && c !== \"\\n\");\n\n            return { value, c };\n        }\n\n        // multi-line comments\n        if (c === STAR) {\n\n            while (c) {\n                value += c;\n                c = next();\n\n                // check for end of comment\n                if (c === STAR) {\n                    value += c;\n                    c = next();\n                    \n                    //end of comment\n                    if (c === SLASH) {\n                        value += c;\n\n                        /*\n                         * The single-line comment functionality cues up the\n                         * next character, so we do the same here to avoid\n                         * splitting logic later.\n                         */\n                        c = next();\n                        return { value, c };\n                    }\n                }\n            }\n\n            unexpectedEOF();\n            \n        }\n\n        // if we've made it here, there's an invalid character\n        unexpected(c);        \n    }\n\n\n    /**\n     * Convenience function for throwing unexpected character errors.\n     * @param {string} c The unexpected character.\n     * @returns {void}\n     * @throws {UnexpectedChar} always.\n     */\n    function unexpected(c) {\n        throw new UnexpectedChar(c, locate());\n    }\n\n    /**\n     * Convenience function for throwing unexpected EOF errors.\n     * @returns {void}\n     * @throws {UnexpectedEOF} always.\n     */\n    function unexpectedEOF() {\n        throw new UnexpectedEOF(locate());\n    }\n\n    let c = next();\n\n    while (offset < text.length) {\n\n        while (isWhitespace(c)) {\n            c = next();\n        }\n\n        if (!c) {\n            break;\n        }\n\n        const start = locate();\n\n        // check for easy case\n        if (knownTokenTypes.has(c)) {\n            tokens.push(createToken(knownTokenTypes.get(c), c, start));\n            c = next();\n        } else if (isKeywordStart(c)) {\n            const result = readKeyword(c);\n            let value = result.value;\n            c = result.c;\n            tokens.push(createToken(knownTokenTypes.get(value), value, start));\n        } else if (isNumberStart(c)) {\n            const result = readNumber(c);\n            let value = result.value;\n            c = result.c;\n            tokens.push(createToken(\"Number\", value, start));\n        } else if (c === QUOTE$1) {\n            const result = readString(c);\n            let value = result.value;\n            c = result.c;\n            tokens.push(createToken(\"String\", value, start));\n        } else if (c === SLASH && options.comments) {\n            const result = readComment(c);\n            let value = result.value;\n            c = result.c;\n            tokens.push(createToken(value.startsWith(\"//\") ? \"LineComment\" : \"BlockComment\", value, start, locate()));\n        } else {\n            unexpected(c);\n        }\n    }\n\n    return tokens;\n\n}\n\n/**\n * @fileoverview Momoa JSON AST types\n * @author Nicholas C. Zakas\n */\n\nconst types = {\n    document(body, parts = {}) {\n        return {\n            type: \"Document\",\n            body,\n            ...parts\n        };\n    },\n    string(value, parts = {}) {\n        return {\n            type: \"String\",\n            value,\n            ...parts\n        };\n    },\n    number(value, parts = {}) {\n        return {\n            type: \"Number\",\n            value,\n            ...parts\n        };\n    },\n    boolean(value, parts = {}) {\n        return {\n            type: \"Boolean\",\n            value,\n            ...parts\n        };\n    },\n    null(parts = {}) {\n        return {\n            type: \"Null\",\n            value: \"null\",\n            ...parts\n        };\n    },\n    array(elements, parts = {}) {\n        return {\n            type: \"Array\",\n            elements,\n            ...parts\n        };\n    },\n    object(members, parts = {}) {\n        return {\n            type: \"Object\",\n            members,\n            ...parts\n        };\n    },\n    member(name, value, parts = {}) {\n        return {\n            type: \"Member\",\n            name,\n            value,\n            ...parts\n        };\n    },\n\n};\n\n/**\n * @fileoverview JSON parser\n * @author Nicholas C. Zakas\n */\n\n//-----------------------------------------------------------------------------\n// Helpers\n//-----------------------------------------------------------------------------\n\nconst DEFAULT_OPTIONS$1 = {\n    tokens: false,\n    comments: false,\n    ranges: false\n};\n\n/**\n * Converts a JSON-encoded string into a JavaScript string, interpreting each\n * escape sequence.\n * @param {Token} token The string token to convert into a JavaScript string.\n * @returns {string} A JavaScript string.\n */\nfunction getStringValue(token) {\n    \n    // slice off the quotation marks\n    let value = token.value.slice(1, -1);\n    let result = \"\";\n    let escapeIndex = value.indexOf(\"\\\\\");\n    let lastIndex = 0;\n\n    // While there are escapes, interpret them to build up the result\n    while (escapeIndex >= 0) {\n\n        // append the text that happened before the escape\n        result += value.slice(lastIndex, escapeIndex);\n\n        // get the character immediately after the \\\n        const escapeChar = value.charAt(escapeIndex + 1);\n        \n        // check for the non-Unicode escape sequences first\n        if (escapeToChar.has(escapeChar)) {\n            result += escapeToChar.get(escapeChar);\n            lastIndex = escapeIndex + 2;\n        } else if (escapeChar === \"u\") {\n            const hexCode = value.slice(escapeIndex + 2, escapeIndex + 6);\n            if (hexCode.length < 4 || /[^0-9a-f]/i.test(hexCode)) {\n                throw new ErrorWithLocation(\n                    `Invalid unicode escape \\\\u${ hexCode}.`,\n                    {\n                        line: token.loc.start.line,\n                        column: token.loc.start.column + escapeIndex,\n                        offset: token.loc.start.offset + escapeIndex\n                    }\n                );\n            }\n            \n            result += String.fromCharCode(parseInt(hexCode, 16));\n            lastIndex = escapeIndex + 6;\n        } else {\n            throw new ErrorWithLocation(\n                `Invalid escape \\\\${ escapeChar }.`,\n                {\n                    line: token.loc.start.line,\n                    column: token.loc.start.column + escapeIndex,\n                    offset: token.loc.start.offset + escapeIndex\n                }\n            );\n        }\n\n        // find the next escape sequence\n        escapeIndex = value.indexOf(\"\\\\\", lastIndex);\n    }\n\n    // get the last segment of the string value\n    result += value.slice(lastIndex);\n\n    return result;\n}\n\n/**\n * Gets the JavaScript value represented by a JSON token.\n * @param {Token} token The JSON token to get a value for.\n * @returns {*} A number, string, boolean, or `null`. \n */\nfunction getLiteralValue(token) {\n    switch (token.type) {\n    case \"Boolean\":\n        return token.value === \"true\";\n        \n    case \"Number\":\n        return Number(token.value);\n\n    case \"Null\":\n        return null;\n\n    case \"String\":\n        return getStringValue(token);\n    }\n}\n\n//-----------------------------------------------------------------------------\n// Main Function\n//-----------------------------------------------------------------------------\n\n/**\n * \n * @param {string} text The text to parse.\n * @param {boolean} [options.tokens=false] Determines if tokens are returned in\n *      the AST. \n * @param {boolean} [options.comments=false] Determines if comments are allowed\n *      in the JSON.\n * @param {boolean} [options.ranges=false] Determines if ranges will be returned\n *      in addition to `loc` properties.\n * @returns {Object} The AST representing the parsed JSON.\n * @throws {Error} When there is a parsing error. \n */\nfunction parse(text, options) {\n\n    options = Object.freeze({\n        ...DEFAULT_OPTIONS$1,\n        ...options\n    });\n\n    const tokens = tokenize(text, {\n        comments: !!options.comments,\n        ranges: !!options.ranges\n    });\n    let tokenIndex = 0;\n\n    function nextNoComments() {\n        return tokens[tokenIndex++];\n    }\n    \n    function nextSkipComments() {\n        const nextToken = tokens[tokenIndex++];\n        if (nextToken && nextToken.type.endsWith(\"Comment\")) {\n            return nextSkipComments();\n        }\n\n        return nextToken;\n\n    }\n\n    // determine correct way to evaluate tokens based on presence of comments\n    const next = options.comments ? nextSkipComments : nextNoComments;\n\n    function assertTokenValue(token, value) {\n        if (!token || token.value !== value) {\n            throw new UnexpectedToken(token);\n        }\n    }\n\n    function assertTokenType(token, type) {\n        if (!token || token.type !== type) {\n            throw new UnexpectedToken(token);\n        }\n    }\n\n    function createRange(start, end) {\n        return options.ranges ? {\n            range: [start.offset, end.offset]\n        } : undefined;\n    }\n\n    function createLiteralNode(token) {\n        const range = createRange(token.loc.start, token.loc.end);\n\n        return {\n            type: token.type,\n            value: getLiteralValue(token),\n            loc: {\n                start: {\n                    ...token.loc.start\n                },\n                end: {\n                    ...token.loc.end\n                }\n            },\n            ...range\n        };\n    }\n\n\n    function parseProperty(token) {\n        assertTokenType(token, \"String\");\n        const name = createLiteralNode(token);\n\n        token = next();\n        assertTokenValue(token, \":\");\n        const value = parseValue();\n        const range = createRange(name.loc.start, value.loc.end);\n\n        return types.member(name, value, {\n            loc: {\n                start: {\n                    ...name.loc.start\n                },\n                end: {\n                    ...value.loc.end\n                }\n            },\n            ...range\n        });\n    }\n\n    function parseObject(firstToken) {\n\n        // The first token must be a { or else it's an error\n        assertTokenValue(firstToken, \"{\");\n\n        const members = [];\n        let token = next();\n\n        if (token && token.value !== \"}\") {\n            do {\n    \n                // add the value into the array\n                members.push(parseProperty(token));\n    \n                token = next();\n    \n                if (token.value === \",\") {\n                    token = next();\n                } else {\n                    break;\n                }\n            } while (token);\n        }\n\n        assertTokenValue(token, \"}\");\n        const range = createRange(firstToken.loc.start, token.loc.end);\n\n        return types.object(members, {\n            loc: {\n                start: {\n                    ...firstToken.loc.start\n                },\n                end: {\n                    ...token.loc.end\n                }\n            },\n            ...range\n        });\n\n    }\n\n    function parseArray(firstToken) {\n\n        // The first token must be a [ or else it's an error\n        assertTokenValue(firstToken, \"[\");\n\n        const elements = [];\n        let token = next();\n        \n        if (token && token.value !== \"]\") {\n\n            do {\n\n              // add the value into the array\n              elements.push(parseValue(token));\n\n              token = next();\n              \n              if (token.value === \",\") {\n                  token = next();\n              } else {\n                  break;\n              }\n            } while (token);\n        }\n\n        assertTokenValue(token, \"]\");\n        const range = createRange(firstToken.loc.start, token.loc.end);\n\n        return types.array(elements, {\n            type: \"Array\",\n            elements,\n            loc: {\n                start: {\n                    ...firstToken.loc.start\n                },\n                end: {\n                    ...token.loc.end\n                }\n            },\n            ...range\n        });\n\n    }\n\n\n\n    function parseValue(token) {\n\n        token = token || next();\n        \n        switch (token.type) {\n        case \"String\":\n        case \"Boolean\":\n        case \"Number\":\n        case \"Null\":\n            return createLiteralNode(token);\n\n        case \"Punctuator\":\n            if (token.value === \"{\") {\n                return parseObject(token);\n            } else if (token.value === \"[\") {\n                return parseArray(token);\n            }\n            /*falls through*/\n\n        default:\n            throw new UnexpectedToken(token);\n        }\n\n    }\n\n    \n    const docBody = parseValue();\n    \n    const unexpectedToken = next();\n    if (unexpectedToken) {\n        throw new UnexpectedToken(unexpectedToken);\n    }\n    \n    \n    const docParts = {\n        loc: {\n            start: {\n                line: 1,\n                column: 1,\n                offset: 0\n            },\n            end: {\n                ...docBody.loc.end\n            }\n        }\n    };\n    \n\n    if (options.tokens) {\n        docParts.tokens = tokens;\n    }\n\n    if (options.ranges) {\n        docParts.range = createRange(docParts.loc.start, docParts.loc.end);\n    }\n\n    return types.document(docBody, docParts);\n\n}\n\n/**\n * @fileoverview Traversal approaches for Momoa JSON AST.\n * @author Nicholas C. Zakas\n */\n\n//-----------------------------------------------------------------------------\n// Data\n//-----------------------------------------------------------------------------\n\nconst childKeys = new Map([\n    [\"Document\", [\"body\"]],\n    [\"Object\", [\"members\"]],\n    [\"Member\", [\"name\", \"value\"]],\n    [\"Array\", [\"elements\"]],\n    [\"String\", []],\n    [\"Number\", []],\n    [\"Boolean\", []],\n    [\"Null\", []]\n]);\n\n//-----------------------------------------------------------------------------\n// Helpers\n//-----------------------------------------------------------------------------\n\n/**\n * Determines if a given value is an object.\n * @param {*} value The value to check.\n * @returns {boolean} True if the value is an object, false if not. \n */\nfunction isObject(value) {\n    return value && (typeof value === \"object\");\n}\n\n/**\n * Determines if a given value is an AST node.\n * @param {*} value The value to check.\n * @returns {boolean} True if the value is a node, false if not. \n */\nfunction isNode(value) {\n    return isObject(value) && (typeof value.type === \"string\");\n}\n\n//-----------------------------------------------------------------------------\n// Exports\n//-----------------------------------------------------------------------------\n\n/**\n * Traverses an AST from the given node.\n * @param {Node} root The node to traverse from \n * @param {Object} visitor An object with an `enter` and `exit` method. \n */\nfunction traverse(root, visitor) {\n\n    /**\n     * Recursively visits a node.\n     * @param {Node} node The node to visit.\n     * @param {Node} parent The parent of the node to visit.\n     * @returns {void}\n     */\n    function visitNode(node, parent) {\n\n        if (typeof visitor.enter === \"function\") {\n            visitor.enter(node, parent);\n        }\n\n        for (const key of childKeys.get(node.type)) {\n            const value = node[key];\n\n            if (isObject(value)) {\n                if (Array.isArray(value)) {\n                    value.forEach(child => visitNode(child, node));\n                } else if (isNode(value)) {\n                    visitNode(value, node);\n                }\n            }\n        }\n\n        if (typeof visitor.exit === \"function\") {\n            visitor.exit(node, parent);\n        }\n    }\n\n    visitNode(root);\n}\n\n/**\n * Creates an iterator over the given AST.\n * @param {Node} root The root AST node to traverse. \n * @param {Function} [filter] A filter function to determine which steps to\n *      return;\n * @returns {Iterator} An iterator over the AST.  \n */\nfunction iterator(root, filter = () => true) {\n\n    const traversal = [];\n\n    traverse(root, {\n        enter(node, parent) {\n            traversal.push({ node, parent, phase: \"enter\" });\n        },\n        exit(node, parent) {\n            traversal.push({ node, parent, phase: \"exit\" });\n        }\n    });\n\n    return traversal.filter(filter).values();\n}\n\n/**\n * @fileoverview Evaluator for Momoa AST.\n * @author Nicholas C. Zakas\n */\n\n//-----------------------------------------------------------------------------\n// Exports\n//-----------------------------------------------------------------------------\n\n/**\n * Evaluates a Momoa AST node into a JavaScript value.\n * @param {Node} node The node to interpet.\n * @returns {*} The JavaScript value for the node. \n */\nfunction evaluate(node) {\n    switch (node.type) {\n    case \"String\":\n    case \"Number\":\n    case \"Boolean\":\n        return node.value;\n\n    case \"Null\":\n        return null;\n\n    case \"Array\":\n        return node.elements.map(evaluate);\n\n    case \"Object\": {\n\n        const object = {};\n\n        node.members.forEach(member => {\n            object[evaluate(member.name)] = evaluate(member.value);\n        });    \n\n        return object;\n    }    \n\n    case \"Document\":\n        return evaluate(node.body);\n\n    case \"Property\":\n        throw new Error(\"Cannot evaluate object property outside of an object.\");\n\n    default:\n        throw new Error(`Unknown node type ${ node.type }.`);\n    }\n}\n\n/**\n * @fileoverview Printer for Momoa AST.\n * @author Nicholas C. Zakas\n */\n\n//-----------------------------------------------------------------------------\n// Exports\n//-----------------------------------------------------------------------------\n\n/**\n * Converts a Momoa AST back into a JSON string.\n * @param {Node} node The node to print.\n * @param {int} [options.indent=0] The number of spaces to indent each line. If\n *      greater than 0, then newlines and indents will be added to output. \n * @returns {string} The JSON representation of the AST.\n */\nfunction print(node, { indent = 0 } = {}) {\n    const value = evaluate(node);\n    return JSON.stringify(value, null, indent);\n}\n\n/**\n * @fileoverview File defining the interface of the package.\n * @author Nicholas C. Zakas\n */\n\nexports.evaluate = evaluate;\nexports.iterator = iterator;\nexports.parse = parse;\nexports.print = print;\nexports.tokenize = tokenize;\nexports.traverse = traverse;\nexports.types = types;\n","import { Node } from '@humanwhocodes/momoa';\nimport { HintIssue } from './types';\n\nexport function makeIssue(message: string, node: Node): HintIssue {\n  return {\n    message,\n    severity: 'error',\n    // node,\n    from: node.loc.start.offset,\n    to: node.loc.end.offset,\n  };\n}\n\nexport class HintError extends Error {\n  issues: HintIssue[] = [];\n\n  constructor(issues: HintIssue[]) {\n    super();\n    // restore prototype chain\n    const actualProto = new.target.prototype;\n    Object.setPrototypeOf(this, actualProto);\n    this.issues = issues;\n  }\n\n  get message() {\n    return JSON.stringify(this.issues, null, 2);\n  }\n}\n","import { GeoJSON } from 'geojson';\n\nexport type GeoJSONTypeSet = Set<GeoJSON['type']>;\n\nexport interface HintIssue {\n  from: number;\n  to: number;\n  node?: Node;\n  severity: 'error';\n  message: string;\n}\n\nexport interface Ctx {\n  issues: HintIssue[];\n  valid: Array<undefined | HintIssue[]>;\n}\n\nexport const GEOJSON_FEATURE_TYPE = new Set<GeoJSON['type']>(['Feature']);\n\nexport const GEOJSON_GEOMETRY_TYPES = new Set<GeoJSON['type']>([\n  'Point',\n  'MultiPoint',\n  'Polygon',\n  'MultiPolygon',\n  'LineString',\n  'MultiLineString',\n  'GeometryCollection',\n]);\n\nexport const GEOJSON_GEOMETRY_TYPES_EX_GEOMETRY_COLLECTION = new Set<\n  GeoJSON['type']\n>([\n  'Point',\n  'MultiPoint',\n  'Polygon',\n  'MultiPolygon',\n  'LineString',\n  'MultiLineString',\n]);\n\nexport const GEOJSON_TYPES = new Set<GeoJSON['type']>(\n  Array.from(GEOJSON_GEOMETRY_TYPES).concat([\n  'Feature',\n  'FeatureCollection',\n]));\n","import { Ctx, GeoJSONTypeSet } from './types';\nimport { GeoJSON } from 'geojson';\nimport { HintError, makeIssue } from './errors';\nimport { Node } from '@humanwhocodes/momoa';\n\nexport function getType(ctx: Ctx, node: Node, allowedTypes: GeoJSONTypeSet) {\n  if (node.type !== 'Object') {\n    throw new HintError([\n      makeIssue('Expected an object, but found an incorrect type.', node),\n    ]);\n  }\n\n  const typeMember = node.members.find((member) => {\n    return member.name.value === 'type';\n  });\n\n  if (!typeMember) {\n    ctx.issues.push(\n      makeIssue('This GeoJSON object is missing its type member.', node)\n    );\n    return {};\n  }\n\n  const value = typeMember.value;\n\n  if (value.type !== 'String') {\n    ctx.issues.push(\n      makeIssue('The type member should have been a string.', node)\n    );\n\n    return {};\n  }\n\n  if (!allowedTypes.has(value.value as any)) {\n    ctx.issues.push(\n      makeIssue('This type of GeoJSON object is not allowed here.', node)\n    );\n\n    return {};\n  }\n\n  return {\n    type: value.value as GeoJSON['type'],\n    objectNode: node,\n  };\n}\n","import { makeIssue } from './errors';\nimport { ObjectNode } from '@humanwhocodes/momoa';\nimport { Ctx } from './types';\n\nexport function getMemberValue(ctx: Ctx, node: ObjectNode, name: string) {\n  const member = node.members.find((member) => {\n    return member.name.value === name;\n  });\n\n  if (!member) {\n    ctx.issues.push(\n      makeIssue(\n        `This GeoJSON object requires a ${name} member but it is missing.`,\n        node\n      )\n    );\n\n    return null;\n  }\n\n  return member.value;\n}\n","import { makeIssue } from './errors';\nimport { Node, ArrayNode } from '@humanwhocodes/momoa';\nimport { Ctx } from './types';\n\nexport function getArray(ctx: Ctx, node: Node | null): ArrayNode | null {\n  if (node?.type === 'Array') return node;\n  if (node) {\n    ctx.issues.push(makeIssue('This must be an array.', node));\n  }\n  return null;\n}\n","import { makeIssue } from './errors';\nimport { Node, ObjectNode } from '@humanwhocodes/momoa';\nimport { Ctx } from './types';\n\nexport function getObject(ctx: Ctx, node: Node | null): ObjectNode | null {\n  if (node?.type === 'Object') return node;\n  if (node) {\n    ctx.issues.push(makeIssue('This must be an object.', node));\n  }\n  return null;\n}\n","import { Node } from '@humanwhocodes/momoa';\nimport { makeIssue } from './errors';\nimport { Ctx } from './types';\n\nexport function arrayIsNumbers(ctx: Ctx, elements: Node[], name: string) {\n  for (const element of elements) {\n    if (element.type !== 'Number') {\n      ctx.issues.push(\n        makeIssue(`Each element in a ${name} must be a number.`, element)\n      );\n      return;\n    }\n  }\n}\n","import { makeIssue } from './errors';\nimport { ArrayNode } from '@humanwhocodes/momoa';\nimport { arrayIsNumbers } from './array_is_numbers';\nimport { Ctx } from './types';\n\nexport function enforcePosition(ctx: Ctx, node: ArrayNode | null) {\n  // This error has already been caught. Allow a no-op for simplicity.\n  if (node === null) return;\n\n  if (node.elements.length < 2 || node.elements.length > 3) {\n    ctx.issues.push(\n      makeIssue(\n        `A position should have 2 or 3 elements - found ${node.elements.length}.`,\n        node\n      )\n    );\n  }\n\n  arrayIsNumbers(ctx, node.elements, 'position');\n}\n","import { makeIssue } from './errors';\nimport { enforcePosition } from './enforce_position';\nimport { enforceSamePosition } from './enforce_same_position';\nimport { Node, ArrayNode } from '@humanwhocodes/momoa';\nimport { Ctx } from './types';\n\nfunction getArray(ctx: Ctx, node: Node): ArrayNode | null {\n  if (node.type !== 'Array') {\n    ctx.issues.push(\n      makeIssue('Expected to find an array of positions here.', node)\n    );\n    return null;\n  }\n  return node;\n}\n\ntype PositionKind = 'Polygon' | 'LineString';\n\nexport function enforcePositionArray(\n  ctx: Ctx,\n  node: Node | null,\n  kind?: PositionKind\n) {\n  // This error has already been caught. Allow a no-op for simplicity.\n  if (node === null) return;\n\n  node = getArray(ctx, node);\n  if (!node) return;\n\n  for (const element of node.elements) {\n    if (element.type !== 'Array') {\n      ctx.issues.push(\n        makeIssue(\n          'Expected to find a position here, found another type.',\n          element\n        )\n      );\n      return;\n    } else {\n      enforcePosition(ctx, element);\n    }\n  }\n\n  switch (kind) {\n    case 'LineString': {\n      if (node.elements.length < 2) {\n        ctx.issues.push(\n          makeIssue('Expected to find two or more positions here.', node)\n        );\n      }\n      break;\n    }\n    case 'Polygon':\n      if (node.elements.length < 4) {\n        ctx.issues.push(\n          makeIssue('Expected to find four or more positions here.', node)\n        );\n      }\n      enforceSamePosition(ctx, node);\n      break;\n  }\n}\n\nexport function enforcePositionArray2(\n  ctx: Ctx,\n  node: Node | null,\n  kind?: PositionKind\n) {\n  // This error has already been caught. Allow a no-op for simplicity.\n  if (node === null) return;\n\n  node = getArray(ctx, node);\n  if (!node) return;\n\n  for (const element of node.elements) {\n    enforcePositionArray(ctx, element, kind);\n  }\n}\n\nexport function enforcePositionArray3(\n  ctx: Ctx,\n  node: ArrayNode | null,\n  kind?: PositionKind\n) {\n  // This error has already been caught. Allow a no-op for simplicity.\n  if (node === null) return;\n\n  node = getArray(ctx, node);\n  if (!node) return;\n\n  for (const element of node.elements) {\n    enforcePositionArray2(ctx, element, kind);\n  }\n}\n","import { makeIssue } from './errors';\nimport { ArrayNode, NumberNode } from '@humanwhocodes/momoa';\nimport { Ctx } from './types';\n\nexport function enforceSamePosition(ctx: Ctx, node: ArrayNode) {\n  const first = node.elements[0] as ArrayNode;\n  const last = node.elements[node.elements.length - 1] as ArrayNode;\n  const len = Math.max(first.elements.length, last.elements.length);\n\n  for (let j = 0; j < len; j++) {\n    const firstValue = (first.elements[j] as NumberNode | undefined)?.value;\n    const secondValue = (last.elements[j] as NumberNode | undefined)?.value;\n    if (firstValue !== secondValue) {\n      ctx.issues.push(\n        makeIssue(\n          'First and last positions of a Polygon or MultiPolygon’s ring should be the same.',\n          first\n        ),\n        makeIssue(\n          'First and last positions of a Polygon or MultiPolygon’s ring should be the same.',\n          last\n        )\n      );\n      return;\n    }\n  }\n}\n","import { makeIssue } from './errors';\nimport { ObjectNode } from '@humanwhocodes/momoa';\nimport { getArray } from './get_array';\nimport { arrayIsNumbers } from './array_is_numbers';\nimport { Ctx } from './types';\n\nexport function enforceBbox(ctx: Ctx, node: ObjectNode) {\n  const member = node.members.find((member) => {\n    return member.name.value === 'bbox';\n  });\n\n  // bboxes are optional\n  if (member === undefined) return;\n\n  const array = getArray(ctx, member.value);\n\n  if (!array) return;\n\n  if (!(array.elements.length === 4 || array.elements.length === 6)) {\n    ctx.issues.push(makeIssue('A bbox must have 4 or 6 positions', array));\n  }\n\n  arrayIsNumbers(ctx, array.elements, 'bbox');\n}\n","import { makeIssue } from './errors';\nimport { ObjectNode, MemberNode } from '@humanwhocodes/momoa';\nimport { Ctx } from './types';\n\ntype PropertiesFrom = 'Feature' | 'FeatureCollection' | 'Geometry';\n\nfunction forbidProperty(\n  ctx: Ctx,\n  member: MemberNode,\n  propertiesFrom: PropertiesFrom,\n  name: string\n) {\n  if (member.name.value === name) {\n    ctx.issues.push(\n      makeIssue(\n        `${propertiesFrom} objects cannot contain a member named ${member.name.value}`,\n        member.name\n      )\n    );\n  }\n}\n\nconst FORBIDDEN_PROPERTIES = {\n  Geometry: ['properties', 'geometry', 'features'],\n  Feature: ['features'],\n  FeatureCollection: ['properties', 'coordinates'],\n} as const;\n\nexport function forbidConfusingProperties(\n  ctx: Ctx,\n  node: ObjectNode,\n  propertiesFrom: PropertiesFrom\n) {\n  for (const member of node.members) {\n    for (const property of FORBIDDEN_PROPERTIES[propertiesFrom]) {\n      forbidProperty(ctx, member, propertiesFrom, property);\n    }\n  }\n}\n","import {\n  parse,\n  evaluate,\n  DocumentNode,\n  Node,\n  ObjectNode,\n} from '@humanwhocodes/momoa';\nimport { GeoJSON } from 'geojson';\nimport { HintError, makeIssue } from './errors';\nimport {\n  GeoJSONTypeSet,\n  GEOJSON_TYPES,\n  GEOJSON_GEOMETRY_TYPES,\n  GEOJSON_GEOMETRY_TYPES_EX_GEOMETRY_COLLECTION,\n  GEOJSON_FEATURE_TYPE,\n  HintIssue,\n  Ctx,\n} from './types';\nimport { getType } from './get_type';\nimport { getMemberValue } from './get_member_value';\nimport { getArray } from './get_array';\nimport { getObject } from './get_object';\nimport { enforcePosition } from './enforce_position';\nimport { checkDuplicateKeys } from './check_duplicate_keys';\nimport {\n  enforcePositionArray,\n  enforcePositionArray2,\n  enforcePositionArray3,\n} from './enforce_position_array';\nimport { enforceBbox } from './enforce_bbox';\nimport { forbidConfusingProperties } from './forbid_confusing_properties';\n\ntype Checker = (ctx: Ctx, node: ObjectNode) => void;\n\nfunction getCoordinates(ctx: Ctx, node: ObjectNode) {\n  const coordinatesMember = getMemberValue(ctx, node, 'coordinates');\n  if (!coordinatesMember) return null;\n  return getArray(ctx, coordinatesMember);\n}\n\nconst checkGeometryShared: Checker = (ctx, node) => {\n  enforceBbox(ctx, node);\n  forbidConfusingProperties(ctx, node, 'Geometry');\n};\n\nconst checkLineString: Checker = (ctx, node) => {\n  enforcePositionArray(ctx, getCoordinates(ctx, node), 'LineString');\n  checkGeometryShared(ctx, node);\n};\n\nconst checkMultiLineString: Checker = (ctx, node) => {\n  enforcePositionArray2(ctx, getCoordinates(ctx, node), 'LineString');\n  checkGeometryShared(ctx, node);\n};\n\nconst checkPolygon: Checker = (ctx, node) => {\n  enforcePositionArray2(ctx, getCoordinates(ctx, node), 'Polygon');\n  checkGeometryShared(ctx, node);\n};\n\nconst checkMultiPolygon: Checker = (ctx, node) => {\n  enforcePositionArray3(ctx, getCoordinates(ctx, node), 'Polygon');\n  checkGeometryShared(ctx, node);\n};\n\nconst checkPoint: Checker = (ctx, node) => {\n  enforcePosition(ctx, getCoordinates(ctx, node));\n  checkGeometryShared(ctx, node);\n};\n\nconst checkMultiPoint: Checker = (ctx, node) => {\n  enforcePositionArray(ctx, getCoordinates(ctx, node));\n  checkGeometryShared(ctx, node);\n};\n\nconst checkGeometryCollection: Checker = (ctx, node) => {\n  checkGeometryShared(ctx, node);\n  const geometriesMember = getArray(\n    ctx,\n    getMemberValue(ctx, node, 'geometries')\n  );\n  if (!geometriesMember) return;\n  for (const element of geometriesMember.elements) {\n    checkObject(ctx, element, GEOJSON_GEOMETRY_TYPES_EX_GEOMETRY_COLLECTION);\n  }\n};\n\nconst checkFeature: Checker = (ctx, node) => {\n  forbidConfusingProperties(ctx, node, 'Feature');\n  const geometryMember = getMemberValue(ctx, node, 'geometry');\n  enforceBbox(ctx, node);\n  if (geometryMember?.type !== 'Null') {\n    const geometry = getObject(ctx, geometryMember);\n    if (geometry) checkObject(ctx, geometry, GEOJSON_GEOMETRY_TYPES);\n  }\n\n  const idMember = node.members.find((member) => {\n    return member.name.value === 'id';\n  });\n  if (\n    idMember &&\n    !(idMember.value.type === 'String' || idMember.value.type === 'Number')\n  ) {\n    ctx.issues.push(\n      makeIssue(`The Feature id must be a string or number.`, node)\n    );\n  }\n\n  const properties = getMemberValue(ctx, node, 'properties');\n  if (!properties) {\n    ctx.issues.push(makeIssue(`The properties member is missing.`, node));\n    return;\n  }\n\n  const { type } = properties;\n\n  if (!(type === 'Object' || type === 'Null')) {\n    ctx.issues.push(\n      makeIssue(`The Feature properties member can be an object or null.`, node)\n    );\n  }\n};\n\nconst checkFeatureCollection: Checker = (ctx, node) => {\n  forbidConfusingProperties(ctx, node, 'FeatureCollection');\n  const featuresMember = getArray(ctx, getMemberValue(ctx, node, 'features'));\n  if (!featuresMember) return;\n  for (const feature of featuresMember.elements) {\n    const beforeCount = ctx.issues.length;\n    const obj = getObject(ctx, feature);\n    if (obj) {\n      getType(ctx, obj, GEOJSON_FEATURE_TYPE);\n      checkFeature(ctx, obj);\n    }\n    ctx.valid.push(\n      ctx.issues.length === beforeCount\n        ? undefined\n        : ctx.issues.slice(beforeCount)\n    );\n  }\n};\n\nconst CHECKERS: Record<GeoJSON['type'], Checker> = {\n  LineString: checkLineString,\n  MultiLineString: checkMultiLineString,\n\n  Polygon: checkPolygon,\n  MultiPolygon: checkMultiPolygon,\n\n  Point: checkPoint,\n  MultiPoint: checkMultiPoint,\n\n  GeometryCollection: checkGeometryCollection,\n\n  Feature: checkFeature,\n  FeatureCollection: checkFeatureCollection,\n};\n\nfunction checkObject(\n  ctx: Ctx,\n  node: Node,\n  typeSet: GeoJSONTypeSet = GEOJSON_TYPES\n) {\n  const { type, objectNode } = getType(ctx, node, typeSet);\n  if (!(type && objectNode)) return;\n  checkDuplicateKeys(ctx, objectNode);\n  CHECKERS[type](ctx, objectNode);\n}\n\nfunction checkInternal(jsonStr: string): {\n  ast: DocumentNode | undefined;\n  ctx: Ctx;\n} {\n  const ctx: Ctx = {\n    issues: [],\n    valid: [],\n  };\n  let ast;\n  try {\n    ast = parse(jsonStr, {\n      ranges: true,\n    });\n    checkObject(ctx, ast.body);\n  } catch (e: unknown) {\n    ctx.issues.push({\n      message: `Invalid JSON: ${(e as Error).message}`,\n      from: 0,\n      to: 0,\n      severity: 'error',\n    });\n  }\n\n  return { ast, ctx };\n}\n\n/**\n * Given a string of possibly valid GeoJSON data,\n * return an array of issues. This will handle invalid JSON\n * data, invalid GeoJSON structure, and anything else that will\n * prevent this string of data from being parsed and\n * displayed on a map.\n *\n * check-geojson looks for invalid structure and invalid syntax.\n * It does not check for complex geometry issues like\n * self-intersections, which are hard to detect and don't cause\n * failures in most display & manipulation software.\n */\nexport const getIssues = (jsonStr: string): HintIssue[] => {\n  return checkInternal(jsonStr).ctx.issues;\n};\n\n/**\n * This catches the same issues as `getIssues`, but instead\n * of returning a list of issues, it will throw a HintError\n * if any errors are detected, and return the parsed\n * GeoJSON as an object if no errors are.\n */\nexport const check = (jsonStr: string): GeoJSON => {\n  const { ctx, ast } = checkInternal(jsonStr);\n  if (ctx.issues.length || !ast) throw new HintError(ctx.issues);\n  return evaluate(ast);\n};\n\n/**\n * This method will allow you to parse a possibly-valid\n * bit of GeoJSON data. If nothing can be parsed, it will\n * throw a HintError. However, if the GeoJSON can be parsed,\n * it will return an object with valid features\n * and rejected features along with the reasons why those\n * features were rejected.\n */\nexport const scavenge = (\n  jsonStr: string\n): {\n  result: GeoJSON;\n  rejected: Array<{ feature: any; reasons: HintIssue[] }>;\n} => {\n  const {\n    ctx: { issues, valid },\n    ast,\n  } = checkInternal(jsonStr);\n  // If GeoJSON can't be parsed, throw.\n  if (!ast) throw new HintError(issues);\n  const result = evaluate(ast) as GeoJSON;\n  // If everything was fine, return.\n  if (!issues.length) return { result, rejected: [] };\n  // If there were errors but it's a featurecollection, sift\n  if (result.type === 'FeatureCollection') {\n    return {\n      result: {\n        ...result,\n        features: result.features.filter((_, i) => {\n          return valid[i] === undefined;\n        }),\n      },\n      rejected: result.features.flatMap((feature, i) => {\n        const reasons = valid[i];\n        if (reasons) {\n          return [\n            {\n              feature,\n              reasons,\n            },\n          ];\n        }\n        return [];\n      }),\n    };\n  }\n  // Otherwise, throw\n  throw new HintError(issues);\n};\n\nexport { HintError, HintIssue };\n","import { makeIssue } from './errors';\nimport { ObjectNode } from '@humanwhocodes/momoa';\nimport { Ctx } from './types';\n\nexport function checkDuplicateKeys(ctx: Ctx, parent: ObjectNode): ObjectNode {\n  const keys = new Set<string>();\n  for (const node of parent.members) {\n    const {\n      name: { value },\n    } = node;\n    if (keys.has(value)) {\n      ctx.issues.push(\n        makeIssue('Duplicate properties are ambiguous in GeoJSON', node)\n      );\n    }\n    keys.add(value);\n  }\n  return parent;\n}\n"],"names":["expectedKeywords","Map","escapeToChar","knownTokenTypes","ErrorWithLocation","Error","constructor","message","line","column","index","super","this","UnexpectedChar","unexpected","loc","UnexpectedToken","token","type","value","start","UnexpectedEOF","DEFAULT_OPTIONS","comments","ranges","isWhitespace","c","test","isDigit","isHexDigit","isKeywordStart","isNumberStart","DEFAULT_OPTIONS$1","tokens","getLiteralValue","Number","slice","result","escapeIndex","indexOf","lastIndex","escapeChar","charAt","has","get","offset","hexCode","length","String","fromCharCode","parseInt","getStringValue","evaluate_1","evaluate","node","elements","map","object","members","forEach","member","name","body","makeIssue","severity","from","to","end","HintError","issues","_this","_Error","call","actualProto","prototype","Object","setPrototypeOf","key","JSON","stringify","GEOJSON_FEATURE_TYPE","Set","GEOJSON_GEOMETRY_TYPES","GEOJSON_GEOMETRY_TYPES_EX_GEOMETRY_COLLECTION","GEOJSON_TYPES","Array","concat","getType","ctx","allowedTypes","typeMember","find","push","objectNode","getMemberValue","getArray","getObject","arrayIsNumbers","_step","_iterator","done","element","enforcePosition","enforcePositionArray","kind","first","last","len","Math","max","j","_first$elements$j","_last$elements$j","enforceSamePosition","enforcePositionArray2","_step2","_iterator2","_createForOfIteratorHelperLoose","enforceBbox","undefined","array","forbidProperty","propertiesFrom","FORBIDDEN_PROPERTIES","Geometry","Feature","FeatureCollection","forbidConfusingProperties","getCoordinates","coordinatesMember","checkGeometryShared","checkFeature","geometryMember","geometry","checkObject","idMember","properties","CHECKERS","LineString","MultiLineString","Polygon","MultiPolygon","enforcePositionArray3","_step3","_iterator3","Point","MultiPoint","GeometryCollection","geometriesMember","featuresMember","beforeCount","obj","valid","typeSet","_getType","checkDuplicateKeys","parent","keys","add","checkInternal","jsonStr","ast","text","options","freeze","newLine","createToken","tokenType","startLoc","endLoc","endOffset","range","next","locate","readKeyword","readString","i","unexpectedEOF","readNumber","isPositiveDigit","readComment","startsWith","tokenize","tokenIndex","nextSkipComments","nextToken","endsWith","assertTokenValue","createRange","createLiteralNode","parseProperty","assertTokenType","parseValue","parts","types","firstToken","parseObject","parseArray","docBody","unexpectedToken","docParts","parse","e","getIssues","check","scavenge","_checkInternal2","_checkInternal2$ctx","rejected","features","filter","_","flatMap","feature","reasons"],"mappings":"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"}